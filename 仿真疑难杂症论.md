# 仿真疑难杂症论

by zhangao

本文件用于解决仿真中遇到的各种bug

##### 1.AttributeError: 'int' object has no attribute '__rdiv__'

![image-20240626210250732](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240626210250732.png)

解决方式：将提示错误所在的地方的函数改成异步函数

![image-20240626210935744](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240626210935744.png)

##### 2. 使用python向模块发送一个输入测试序列时，波形图显示输入握手信号全0

##### ![image-20240627112233776](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627112233776.png)

原因在于，在输入一个序列的数据的时候，python仅仅是将数据发出去，送到python的发送序列中，发完就结束了，python在这个发送循环之外没有写其他逻辑的话，仿真在发完数据之后就结束了，没有等到verilog对输入进行处理（verilog和python是异步执行的），就认为仿真结束了，生成的波形文件里面就没有记录到模块信号。

![image-20240627112312416](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627112312416.png)

解决方式是：

1. 在输入完数据之后强行等待一段时间，等verilog处理完毕再结束仿真

   ![image-20240627112847695](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240627112847695.png)

2. 在python里写：收到verilog对应的响应之后再结束仿真

##### 3. 仿真里面的payloadlenth规定：

![image-20240711112955067](C:\Users\Aopir\AppData\Roaming\Typora\typora-user-images\image-20240711112955067.png)

![image-20240711113007159](C:\Users\Aopir\AppData\Roaming\Typora\typora-user-images\image-20240711113007159.png)

上图表示payloadlenth用这个列表规定，共发11个包，每个包长为列表元素的值

##### 4. rawpkt_seq函数导致的包长改变问题

![image-20240711113200519](C:\Users\Aopir\AppData\Roaming\Typora\typora-user-images\image-20240711113200519.png)

这个函数是ascii码搞的，从0030开始，搞到0039之后进位成3031，直接会把包长搞多一个字节

##### 5. 关于仿真的异步函数问题：

例子：下面的就是典型的异步函数，这是python的另一套工作逻辑，即把操作放在一个fifo中，并不会立即执行，需要和await配套使用。

async def send_reli_req(self, s_info, s_id, key_msg, type):
    request = Reli_reqTransaction()
    request.task_req = (s_info << S_INFO_OFFSET | key_msg << KEY_MSG_OFFSET | type << TYPE_OFFSET | s_id << S_ID_OFFSET)
    await self.Reli_req_source.send(request)

并不是仿真中所有情况都需要异步函数，比如下面的一个造expect包的函数（为了给assert服务）

 def generate_nack_pkt(self, initial_npn=0x0000_0000, npn_bitmap=0x0000_0000_0000_03E0):
     eth  = Ether(src = "66:77:88:99:aa:bb", dst = "00:11:22:33:44:55",  type= 0x86dd)
     ipv6 = IPv6(nh=0x92, src = "2001::200", dst = "5001::0001:0001", version=6, hlim=255, fl=0, tc=0)
     scmpv6 = self.generate_scmpv6_NACK(pkt_type=0x41, Code=0x01, initial_npn=initial_npn, npn_bitmap=npn_bitmap)
     test_pkt_expect =bytes( eth / ipv6 / scmpv6 )
     return test_pkt_expect

这是python正常的函数，加上了异步之后反而跑不通了，现象如下：

执行这行代码：print("!!!!!!!!!!!!!!!!!!!!",tb.generate_nack_pkt(initial_npn, bitmap))

结果是：!!!!!!!!!!!!!!!!!!!!ccoroutineobject TB.generate nack pktat 0x7f3f30b30740>

将异步删除之后能正常输出字节形式的包

##### 6.cocotb里输出的字节是ASCII码的形式，看到奇怪字符就去查ASCII码表

##### 7. 仿真中打拍子的写法

错误例子：

for i in range(len(rpn_vector)):
    rpn = rpn_vector[i]              #rpn should lower than set
    exp_rpn = exp_rpn_vector[i]
    dst_mac_dat_lost = dst_mac_dat_lost_vector[i]
    s_info_dat_lost = tb.build_s_info(dst_mac_dat_lost, src_mac_dat_lost,
                              vlan_id_dat_lost, src_ip_dat_lost,
                              dst_ip_dat_lost, inport_dat_lost)
    key_msg_dat_lost = (0 << EXP_RPN_OFFSET + EXP_RPN_WIDTH | exp_rpn << EXP_RPN_OFFSET | rpn << RPN_OFFSET)
    print(key_msg_dat_lost)
    await tb.send_reli_req(s_info_dat_lost, s_id_dat_lost,
                    key_msg_dat_lost, type_dat_lost)
    cnt = cnt + 1
    for _ in range(10):
        await RisingEdge(dut.clk)
        await RisingEdge(dut.clk)

我的想法是每次发完一个req之后等待20拍再发下一个，但是实际的波形图显示两个req之间只隔了6拍，原因是：RisingEdge也是异步函数，发送函数也是异步函数，他们会被分到不同的task fifo里，即同时启动，req的send和等待时钟周期会并行执行，互不影响

正确修改：

for i in range(len(rpn_vector)):
    rpn = rpn_vector[i]              #rpn should lower than set
    exp_rpn = exp_rpn_vector[i]
    dst_mac_dat_lost = dst_mac_dat_lost_vector[i]
    s_info_dat_lost = tb.build_s_info(dst_mac_dat_lost, src_mac_dat_lost,
                              vlan_id_dat_lost, src_ip_dat_lost,
                              dst_ip_dat_lost, inport_dat_lost)
    key_msg_dat_lost = (0 << EXP_RPN_OFFSET + EXP_RPN_WIDTH | exp_rpn << EXP_RPN_OFFSET | rpn << RPN_OFFSET)
    print(key_msg_dat_lost)
    await tb.send_reli_req(s_info_dat_lost, s_id_dat_lost,
                    key_msg_dat_lost, type_dat_lost)
    cnt = cnt + 1
    **await tb.recv_nack()**
    for _ in range(10):
        await RisingEdge(dut.clk)
        await RisingEdge(dut.clk)

加了上面一句，就解决了问题，因为这么写就是必须要等接收到一个信号之后才能发下一个req，这样就实现了req输入之间打拍子

虽然收发信号也是异步的，但是因为我们模块输出要决定于输入，而且输入是我们自己控制的串行输入，所以输出可以被我们控制（说得比较抽象）
