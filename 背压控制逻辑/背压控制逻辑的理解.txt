对于模块内部通用的背压控制逻辑：进行逻辑绘制和波形图查看之后，得到结论：
always @* begin
    // transfer sink ready state to source
    m_axis_tvalid_next = m_axis_tvalid_reg;
    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;

    store_axis_int_to_output = 1'b0;
    store_axis_int_to_temp = 1'b0;
    store_axis_temp_to_output = 1'b0;
    
    if (m_axis_tready_int_reg) begin
        // input is ready
        if (m_axis_tready || !m_axis_tvalid_reg) begin
            // output is ready or currently not valid, transfer data to output
            m_axis_tvalid_next = m_axis_tvalid_int;
            store_axis_int_to_output = 1'b1;
        end else begin
            // output is not ready, store input in temp
            temp_m_axis_tvalid_next = m_axis_tvalid_int;
            store_axis_int_to_temp = 1'b1;
        end
    end else if (m_axis_tready) begin
        // input is not ready, but output is ready
        m_axis_tvalid_next = temp_m_axis_tvalid_reg;
        temp_m_axis_tvalid_next = 1'b0;
        store_axis_temp_to_output = 1'b1;
    end
end

always @(posedge clk) begin
    if (rst) begin
        m_axis_tvalid_reg <= 1'b0;
        m_axis_tready_int_reg <= 1'b0;
        temp_m_axis_tvalid_reg <= 1'b0;
    end else begin
        m_axis_tvalid_reg <= m_axis_tvalid_next;
        m_axis_tready_int_reg <= m_axis_tready_int_early;
        temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;
    end
在这个代码块中，实现了向下游输出的tvalid值的确定，使用temp寄存器抗下了pipeline的一拍。然后使用
组合逻辑将tvalid_next的值判断（计算）出来，再使用组合逻辑持续赋值的特点对tvalid_next的值进行保持，
直到下一个clk上升沿，将从组合逻辑中计算出来的next值赋给tvalid。
为什么组合逻辑里面的值需要进行保持？因为如果组合逻辑不对值进行保持（持续给其赋值）的话，会生成锁存器，
锁存器在硬件逻辑里是非常危险的。而时序逻辑中只要不对值进行修改，那么值就会一直自动保持。

这段代码的核心思想就是使用组合逻辑计算所需变量下一拍(tvalid_next)的值，同时使用组合逻辑保持先前的值，使用时序逻辑修改对应变量(tvalid)